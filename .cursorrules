# Shopify Smart Pricing - Feature-Based Architecture Rules
# Based on "This Folder Structure Makes Me 100% More Productive" by Web Dev Simplified

## ðŸŽ¯ CORE PRINCIPLE: FEATURE-BASED ORGANIZATION
All code must be organized by BUSINESS FEATURES, not technical categories. Each feature is self-contained with its own components, services, hooks, utils, and types.

## ðŸ“ MANDATORY FOLDER STRUCTURE

### Root Structure
```
src/
â”œâ”€â”€ features/           # ALL business features go here
â”œâ”€â”€ shared/            # ONLY truly global code (used by 3+ features)
â”œâ”€â”€ app/               # Next.js app directory (pages, layouts, globals)
â””â”€â”€ lib/               # Global utilities and configurations
```

### Feature Structure (MANDATORY for every feature)
```
src/features/[feature-name]/
â”œâ”€â”€ components/        # Feature-specific components
â”œâ”€â”€ services/          # Feature-specific services
â”œâ”€â”€ hooks/             # Feature-specific hooks
â”œâ”€â”€ utils/             # Feature-specific utilities
â”œâ”€â”€ types/             # Feature-specific types
â””â”€â”€ index.ts           # Public API export (REQUIRED)
```

### Shared Structure (ONLY for truly global code)
```
src/shared/
â”œâ”€â”€ components/        # UI components used by 3+ features
â”œâ”€â”€ services/          # Global services (auth, API client)
â”œâ”€â”€ hooks/             # Global hooks (used everywhere)
â”œâ”€â”€ utils/             # Global utilities
â”œâ”€â”€ types/             # Global types
â””â”€â”€ lib/               # Global configurations
```

## ðŸš« STRICT PROHIBITIONS

### âŒ NEVER CREATE THESE FOLDERS
- `src/components/` (use `src/shared/components/` or feature-specific)
- `src/services/` (use `src/shared/services/` or feature-specific)
- `src/hooks/` (use `src/shared/hooks/` or feature-specific)
- `src/utils/` (use `src/shared/utils/` or feature-specific)
- `src/types/` (use `src/shared/types/` or feature-specific)

### âŒ NEVER PLACE BUSINESS LOGIC IN SHARED
- No feature-specific business logic in `shared/`
- No components that belong to one feature
- No services that handle specific business rules
- No types that are feature-specific

## âœ… MANDATORY RULES

### 1. Feature Creation Rules
- **EVERY** new business feature MUST be created in `src/features/[feature-name]/`
- **EVERY** feature MUST have the complete folder structure (components, services, hooks, utils, types, index.ts)
- **EVERY** feature MUST export its public API through `index.ts`

### 2. Import Rules (STRICT HIERARCHY)
```
App Layer â†’ Features â†’ Shared
```

#### âœ… ALLOWED IMPORTS
- **Within Feature**: Direct imports between files in same feature
- **Cross Feature**: Import ONLY from other features' `index.ts`
- **From Shared**: Import from `shared/` from anywhere
- **App Layer**: Import from features and shared

#### âŒ FORBIDDEN IMPORTS
- Direct imports to other features' internal files
- Imports from `shared/` to feature-specific code
- Circular dependencies between features

### 3. Global Folder Rules
- **ONLY** code used by 3+ features goes in `shared/`
- **ONLY** technical utilities (no business logic)
- **ONLY** truly generic and reusable code
- **QUESTION** every addition to `shared/`

### 4. File Naming Rules
- **Components**: PascalCase (e.g., `PricingCard.tsx`)
- **Services**: camelCase with Service suffix (e.g., `pricingService.ts`)
- **Hooks**: camelCase with use prefix (e.g., `usePricing.ts`)
- **Utils**: camelCase (e.g., `pricingCalculations.ts`)
- **Types**: camelCase with .types.ts suffix (e.g., `pricing.types.ts`)

### 5. Index File Rules
- **EVERY** feature MUST have `index.ts`
- **ONLY** export public API (components, hooks, services, types)
- **NEVER** export internal implementation details
- **USE** barrel exports for clean imports

## ðŸŽ¯ DECISION FRAMEWORK

### When Creating New Code, Ask:
1. **"Is this business logic?"** â†’ Feature folder
2. **"Is this used by 3+ features?"** â†’ Shared folder
3. **"Is this a technical utility?"** â†’ Shared folder
4. **"Does this belong to one business domain?"** â†’ Feature folder

### Feature vs Shared Decision Tree:
```
Is it business logic? 
â”œâ”€â”€ YES â†’ Feature folder
â””â”€â”€ NO â†’ Is it used by 3+ features?
    â”œâ”€â”€ YES â†’ Shared folder
    â””â”€â”€ NO â†’ Feature folder
```

## ðŸ“‹ MANDATORY CHECKLIST FOR EVERY CHANGE

### Before Creating Any File:
- [ ] Is this business logic? â†’ Feature folder
- [ ] Is this used by 3+ features? â†’ Shared folder
- [ ] Does the target folder exist?
- [ ] Is the naming convention correct?

### Before Moving Any File:
- [ ] Does it belong to a specific feature? â†’ Move to feature
- [ ] Is it truly shared? â†’ Move to shared
- [ ] Update all import statements
- [ ] Update feature's index.ts if needed

### Before Adding to Shared:
- [ ] Is it used by 3+ features?
- [ ] Is it truly generic?
- [ ] Does it have no business logic?
- [ ] Is it really needed globally?

## ðŸ—ï¸ CURRENT PROJECT FEATURES

### Existing Features (DO NOT MODIFY STRUCTURE):
- `pricing-strategies/` - Pricing rules and strategies
- `product-management/` - Product CRUD and management
- `analytics-dashboard/` - Analytics and reporting
- `shopify-integration/` - Shopify API integration
- `user-settings/` - User preferences and configuration

### Shared Components (ONLY):
- UI components from shadcn/ui
- Layout components (Header, Sidebar, Footer)
- Common components (LoadingSpinner, ErrorBoundary)
- Global services (API client, auth, storage)
- Generic utilities and types

## ðŸš¨ ENFORCEMENT RULES

### Code Review Checklist:
- [ ] All new files are in correct folders
- [ ] No prohibited folder structures
- [ ] Import hierarchy is respected
- [ ] Feature index.ts exports are updated
- [ ] No business logic in shared/
- [ ] Naming conventions are followed

### Refactoring Rules:
- [ ] Move business logic from shared/ to features/
- [ ] Consolidate related code into features
- [ ] Update imports after moving files
- [ ] Maintain feature boundaries
- [ ] Keep shared/ minimal and focused

## ðŸŽ¯ SUCCESS METRICS

### Good Architecture Signs:
- âœ… Features are self-contained
- âœ… Shared/ is minimal and focused
- âœ… No circular dependencies
- âœ… Clear import hierarchy
- âœ… Easy to find related code
- âœ… Simple to add new features

### Bad Architecture Signs:
- âŒ Business logic in shared/
- âŒ Components scattered across folders
- âŒ Circular dependencies
- âŒ Hard to find related code
- âŒ Complex import paths
- âŒ Shared/ folder growing large

## ðŸ“š REFERENCE

This structure is based on the principles from "This Folder Structure Makes Me 100% More Productive" by Web Dev Simplified, emphasizing:
- Feature-based organization over technical organization
- Co-location of related code
- Clear boundaries between features
- Minimal global/shared code
- Scalable and maintainable architecture

## ðŸ”§ IMPLEMENTATION NOTES

- All new features MUST follow this structure
- Existing code MUST be refactored to follow this structure
- No exceptions to these rules without explicit approval
- Regular architecture reviews to ensure compliance
- Continuous refactoring to maintain structure integrity

## ðŸ”„ DATA FETCHING PATTERNS (MANDATORY)

### React Query (TanStack Query) - REQUIRED for All Data Fetching

**NEVER use useEffect for data fetching.** Always use React Query.

### âœ… CORRECT Pattern:
```typescript
// src/features/[feature]/hooks/useData.ts
import { useQuery } from '@tanstack/react-query';

export function useData(filter?: Filter) {
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ['data', filter], // Include dependencies in key
    queryFn: async () => {
      const res = await fetch('/api/endpoint');
      const response = await res.json();
      if (!response.success) throw new Error(response.error);
      return response.data;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  });

  return { data: data || [], loading: isLoading, error, refetch };
}
```

### âŒ WRONG Pattern (Never Do This):
```typescript
// NEVER use useState + useEffect for data fetching
const [data, setData] = useState([]);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  fetch('/api/endpoint').then(res => setData(res));
}, []);
```

### Mutations (For Updates/Creates/Deletes):
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';

export function useUpdateData() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (data) => {
      const res = await fetch('/api/update', { 
        method: 'POST',
        body: JSON.stringify(data) 
      });
      return res.json();
    },
    onSuccess: () => {
      // Automatically refetch data after update
      queryClient.invalidateQueries({ queryKey: ['data'] });
    },
  });
}

// Usage in component:
const updateData = useUpdateData();
updateData.mutate({ id: 1, value: 'new' });
```

### Query Keys Convention:
- **Simple:** `['products']`
- **With ID:** `['product', productId]`
- **With Filter:** `['products', filter]`
- **Nested:** `['products', productId, 'variants']`

### Cache Configuration:
- **staleTime:** How long data is considered fresh (5 minutes default)
- **gcTime:** How long unused data stays in cache (10 minutes default)
- **refetchOnWindowFocus:** false (don't refetch on tab switch)

### Provider Setup:
- QueryProvider is in `src/shared/components/QueryProvider.tsx`
- Wraps app in `src/app/layout.tsx`
- Global configuration applied to all queries

### Benefits:
- âœ… Automatic caching (no duplicate fetches)
- âœ… Automatic refetching (background updates)
- âœ… No manual loading/error state management
- âœ… Optimistic updates support
- âœ… 70% less boilerplate code

### When to Use:
- **ALL server data fetching** (API calls, database queries)
- **NOT for** local state, form state, or UI state


